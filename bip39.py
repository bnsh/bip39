#! /usr/bin/env python3
# vim: expandtab shiftwidth=4 tabstop=4

"""This is our attempt to recreate the bip39 mnemonic method.
    What do we want? We want to have two modes:

        1. From a 128 bit seed and a password to make the mnemonic.
        2. From a mnemonic and a password to make the 128 bit seed.
    
    https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
    Test vectors
    The test vectors include input entropy, mnemonic and seed. The passphrase "TREZOR" is used for all vectors.

    https://github.com/trezor/python-mnemonic/blob/master/vectors.json
"""

import os
import random
from hmac import HMAC
import hashlib
import argparse
from functools import reduce

def localfile(fname):
    return os.path.realpath(os.path.join(os.path.dirname(__file__), fname))

def generate_entropy(bitsz: int) -> bytes:
    """No, this is _not_ cryptographically secure! Don't use this in real life!
        This is just for our own educational purposes to understand bip39.
    """
    ent = bytes([random.randint(0, 256) for _ in range(0, bitsz // 8)])
    return ent

def byte2hexstr(values: bytes) -> str:
    return "".join(f"{value:02x}" for value in values)

def hexstr2byte(hexstr: str) -> bytes:
    assert len(hexstr) % 2 == 0
    return bytes([int(hexstr[start:(start+2)], 16) for start in range(0, len(hexstr), 2)])

def compute_sha256(values: bytes) -> str:
    s256 = hashlib.sha256()
    s256.update(values)
    return s256.hexdigest()

def compute_hmac_sha512(values: bytes) -> bytes:
    return HMAC("Bitcoin seed".encode("utf-8"), values, hashlib.sha512).hexdigest()

def consume_multiple_of_11_bits(bucket_of_11_or_more_bits: list[int], emitted_indices: list[int]) -> None:
    while len(bucket_of_11_or_more_bits) >= 11:
        ladle_of_exactly_11bits = bucket_of_11_or_more_bits[0:11]
        emitted_indices.append(reduce(lambda acc, x: acc*2+x, ladle_of_exactly_11bits, 0)) # The reduce converts the _single_ bits into a python integer
        ladle_of_exactly_11bits = None
        bucket_of_11_or_more_bits[:] = bucket_of_11_or_more_bits[11:] # We just consumed the first 11 bits. Remove them from the bucket.

def grab_vocabulary(dictfn: str) -> list[str]:
    with open(dictfn, "rt", encoding="utf-8-sig") as vfp:
        vocabulary = [word.strip() for word in vfp.readlines()]
    assert len(vocabulary) == 2048, len(vocabulary)
    return vocabulary

def entropy2mnemonic(values: bytes) -> list[str]:
    # This is a really dumb way of doing it. Educational purposes again
    # I said!
    # ENT is divisible by 32 : call this 32k
    # We take ENT/32 bits of the sha256 hash: 32k/32 = k
    # 32k + k = 33k

    assert 8 * len(values) % 32 == 0

    checksum = compute_sha256(values)
    # https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#user-content-Generating_the_mnemonic
    #     "A checksum is generated by taking the first ENT / 32 bits of its SHA256 hash."
    #     CS = ENT / 32
    #     MS = (ENT + CS) / 11
    #
    # Binesh: This is much simpler than I thought. Really, all we have to do is shift this checksum (256-8*len(values)//32) bits to the left..
    #         8 because the values are in bytes. In our case `ENT` is basic `values`

    cslength = 8 * len(values) // 32

    # bitwise shift are these operators in python: `>>` and `<<`:
    # What it basically does is convert to boolean (in a manner of speaking) and then moving everything however many
    # bits is specified to whichever direction we are talking about. So, by way of example:

    # 17 >> 3: 17 is 10001: 10001 shifted right 1 bit 01000 shifted right 2 bits becomes 00100 and shifted right 3 bits becomes 00010 converted back to decimal becomes 2
    # python3 -c 'print(f"{17 >> 3:d}")' # 2
    # bits at the extreme right end are _dropped_:
    # So, _anything_ that starts with 10xxx will become 2. So, in our case, 16 to 16+7=23 will _all_ become 2
    # which if you think about it, makes it so in a 5 digit bit sequence, we are taking the _first_ 2 bits.
    # The line below is effectively doing this with the 256 bit value of the checksum.
    # In the example above, we have 5 bits, and we wanted the first 2 bits of the value so we shifted right (5-2) = 3 bits.
    # In our real version, we have 256 bits, and we want the first cslength bits of the checksum, so we are shifting right (256-cslength) bits.

    checksum_bip = int(checksum, 16) >> (256-cslength) # checksum_bip is the _first_ `cslength` bits of the sha256.

    emitted_indices = []
    bucket_of_11_or_more_bits = []

    # The for loop is iterating over the _concatenation_ of values and the bip.
    # 8 * len(values)//32
    # 8 * 32 // 32 = 8
    # 8 * 32 = 256

    for bits, bitsz in [(byte, 8) for byte in values] + [(checksum_bip, 8*len(values)//32)]:
        while len(bucket_of_11_or_more_bits) >= 11: # If we have accumulated _more_ than 11 bits:
            consume_multiple_of_11_bits(bucket_of_11_or_more_bits, emitted_indices)

        # range(bitsz-1, -1, -1) because we need to append these in reversed order.
        bitarray = [1 if (bits & (2 ** idx)) == (2 ** idx) else 0 for idx in range(bitsz-1, -1, -1)]
        bucket_of_11_or_more_bits.extend(bitarray)

    if len(bucket_of_11_or_more_bits) >= 11:
        consume_multiple_of_11_bits(bucket_of_11_or_more_bits, emitted_indices)

    assert len(bucket_of_11_or_more_bits) == 0, len(bucket_of_11_or_more_bits)

    vocabulary = grab_vocabulary(localfile("bip39-en.txt"))
    return [vocabulary[idx] for idx in emitted_indices]

#pylint: disable=too-many-locals
def trust_but_verify(*, mnemonic: str) -> bytes:
    # This function will convert to a (ENT, CS) pair and verify that the checksum is valid for
    # the _purported_ ENT. If it is not, it throws a ValueError
    # Our mnemonic consists of n words of 11 bits each.
    # So, we will have n * 11 bits
    # We'll need to verify that n is multiple of 3 (Because, our "checksum" is of size len(ent)//32 # len(ent) is in _bits_
    # https://en.wikipedia.org/wiki/Trust,_but_verify
    assert mnemonic is not None
    mnemonic_list = mnemonic.split(" ")
    idx2word = grab_vocabulary(localfile("bip39-en.txt"))
    word2idx = {word: idx for idx, word in enumerate(idx2word)}
    assert all(word in idx2word for word in mnemonic_list), f"{mnemonic:s} contains words not in the bip39-en dictionary."
    assert len(word2idx) == len(idx2word)
    assert all(idx == word2idx[word] for idx, word in enumerate(idx2word))
    assert all(word == idx2word[idx] for word, idx in word2idx.items())

    ent_plus_cs_sz = len(mnemonic_list) * 11 # 2048 is 11 bits.
    assert ent_plus_cs_sz % 33 == 0 # Has to be an even multiple of 33
    ent_sz = 32 * ent_plus_cs_sz // 33
    cs_sz = ent_plus_cs_sz // 33
    ent_plus_cs_arr = [word2idx[word] for word in mnemonic_list]
    ent_plus_cs = reduce(lambda acc, x: acc * (2 ** 11) + x, ent_plus_cs_arr, 0)

    # Now we need to extract this into an ent and cs portions separately.
    csmask = sum(2 ** idx for idx in range(0, cs_sz))
    csonly = ent_plus_cs & csmask
    entonly = ent_plus_cs >> cs_sz
    entbytes = []
    entonly_sofar = entonly
    for idx in range(0, ent_sz // 8):
        entbytes.append(entonly_sofar & 0x00ff)
        entonly_sofar >>= 8
    entbytes = bytes(reversed(entbytes))
    cksum = int(compute_sha256(entbytes), 16)

    # We need the first cs_sz bits from cksum
    cstbv = cksum >> (256-cs_sz)
    if cstbv != csonly:
        print(f"Oh no! The checksum is not valid! I expected 0x{cstbv:x}, but I found 0x{csonly:x}..")
        print(entbytes.hex())
        print(cs_sz)
        print(mnemonic)

    return entbytes
#pylint: enable=too-many-locals


def mnemonic2derived_seed(*, mnemonic: str, passphrase: str) -> str:
    # https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
    # To create a binary seed from the mnemonic, we use the PBKDF2 function with a mnemonic sentence (in UTF-8 NFKD)
    # used as the password and the string "mnemonic" + passphrase (again in UTF-8 NFKD) used as the salt.
    # The iteration count is set to 2048 and HMAC-SHA512 is used as the pseudo-random function.
    # The length of the derived key is 512 bits (= 64 bytes).

    trust_but_verify(mnemonic=mnemonic)

    pbkdfpassword = mnemonic.encode("utf-8")
    salt = ("mnemonic" + passphrase).encode("utf-8")
    iteration_count = 2048
    key_length = 512 // 8 # 64 bytes
    derived_key = hashlib.pbkdf2_hmac("sha512", pbkdfpassword, salt, iteration_count, dklen=key_length)

    return derived_key.hex()

def derived_seed2prvkey(*, derived_seed: str) -> str:
    derived_bytes = bytes.fromhex(derived_seed)
    hmacsha512 = compute_hmac_sha512(derived_bytes)
    i_l = hmacsha512[0:64]
    i_r = hmacsha512[64:128]
    keyhex = (
        "0488ade4" +    #  32 bits: A fixed prefix (0x0488ADE4 for mainnet private keys),
        "00" +          #   8 bits: Depth (0x00 for master keys),
        "00000000" +    #  32 bits: Parent fingerprint (0x00000000 for master keys),
        "00000000" +    #  32 bits: Child number (0x00000000 for master keys),
        i_r +           # 256 bits: The chain code (I_R)
        "00" +          #   8 bits: a prefix of 0x00
        i_l             # 256 bits: The private key (I_L)
    )
                        # 624 bits? + 32 bits for checksum
# How many base58 digits are 656 bits?
# bits in x (arbitrary integer) =
#   Log[x] / Log[2]
# digits in base58 in x
#   Log[x] / Log[58]
# So.. 656 bits * Log[2] / Log[58] = 111.9839
# Round up to 112
    keybytes = bytes.fromhex(keyhex)
    sha256bytes = bytes.fromhex(compute_sha256(keybytes))
    doublesha256bytes = bytes.fromhex(compute_sha256(sha256bytes))
    key_with_checksum_bytes = keybytes + doublesha256bytes[0:4]
    key_as_int = int(key_with_checksum_bytes.hex(), 16)
    base58digits = []
    keyrem = key_as_int
    while keyrem > 0:
        base58digits.append(keyrem % 58)
        keyrem = keyrem // 58

    base58digits = reversed([0] * (111-len(base58digits)) + base58digits)
    base58alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    return "".join(base58alphabet[val] for val in base58digits)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--passphrase", "-p", type=str, required=True)
    parser.add_argument("--mnemonic", "-m", type=str, required=False)
    args = parser.parse_args()

    seed = mnemonic2derived_seed(mnemonic=args.mnemonic, passphrase=args.passphrase)
    print(f"{seed:s}")

if __name__ == "__main__":
    main()
